clear
clc
addpath(genpath(pwd))
load("kobe32_cacti.mat") %orig,mean,mask

%% FISTA shearlet---------------------------------------------------------------------------------------
maskFrames = size(mask,3);
[height, width, frames] = size(orig);
N = height*width;
M = mask;
x = orig(:,:,1:8); % n×n  no need to transform to N×1
nor = max(x(:));
y = sample(M,x); 

% we don't need to build Psi_r in real other than here for the constant L, 
% we use math tricks to find another way to represent shearlet transform,
% so try to use back tracking version for L that can't easily compute

% each parallel sub matrix is moved to third dimension
% capital-frequency,lowercase-time
scales = 4;
shearletSystem = SLgetShearletSystem2D(0,size(x,1),size(x,2),scales); % 对同一个参数shearletSystem
G = shearletSystem.dualFrameWeights; % n×n
H = shearletSystem.shearlets; % n×n×I, don't forget conj in dec
I = shearletSystem.nShearlets;
H_r = zeros(size(H));

for i=1:I 
    H_r(:,:,i) = H(:,:,i)./G;
end
% L is the Lipschitz constant
L = max(H_r(:));
L = 2*L^2;
L = 4;

iteration = 100;
lambda = 4000;
A = @(d) sample(M,ShearletHr(ifft2withShift(d),shearletSystem));
% 不同于dft，dft的循环卷积矩阵共轭转置恰好是逆变换，这里还不是可以直接用逆变换
AT = @(d) fft2withShift(ShearletHrT(sampleH(M,d),H_r)); 
x_recover = NNFISTA(iteration,I,y,L,lambda,shearletSystem,A,AT);
psnr_x = psnr(x/nor,x_recover/nor);
ssim_x = ssim(x/nor,x_recover/nor);
sprintf("the psnr is %f",psnr_x)

figure(1); 
colormap gray;
suptitle('ISTA Method on Shearlet');
for i=1:8
    subplot(121);   imagesc(x(:,:,i));	axis image off;     title('orig');
    subplot(122);   imagesc(x_ista(:,:,i));  	axis image off;     title({'recon_{ISTA}', ['MSE : ' num2str(mse_x_ista, '%.4e')], ['PSNR : ' num2str(psnr_x_ista, '%.4f')], ['SSIM : ' num2str(ssim_x_ista, '%.4f')]});
    pause(1);
end

